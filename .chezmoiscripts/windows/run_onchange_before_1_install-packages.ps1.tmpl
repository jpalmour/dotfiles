$ErrorActionPreference = 'Stop'

function Ensure-PowerShellModule {
    param([Parameter(Mandatory)][string]$Name)

    $installed = Get-Module -ListAvailable -Name $Name | Sort-Object Version -Descending | Select-Object -First 1

    if (-not $installed) {
        if (-not (Get-Command -Name Install-Module -ErrorAction SilentlyContinue)) {
            Write-Host ("[ERROR] Install-Module not available; install module '{0}' manually." -f $Name) -ForegroundColor Red
            return
        }

        Write-Host ("[INFO] Installing PowerShell module '{0}'..." -f $Name)
        try {
            Install-Module -Name $Name -Scope CurrentUser -Force -AllowClobber -ErrorAction Stop | Out-Null
        } catch {
            Write-Host ("[ERROR] Failed to install module '{0}': {1}" -f $Name, $_.Exception.Message) -ForegroundColor Red
            return
        }
    } else {
        Write-Host ("[INFO] PowerShell module '{0}' already present (v{1})." -f $Name, $installed.Version)
    }

    try {
        Import-Module -Name $Name -ErrorAction Stop
    } catch {
        Write-Host ("[ERROR] Failed to import module '{0}': {1}" -f $Name, $_.Exception.Message) -ForegroundColor Red
    }
}

function Test-CaskaydiaFont {
    $fontDirs = @(
        (Join-Path $env:WINDIR 'Fonts'),
        (Join-Path $env:LOCALAPPDATA 'Microsoft\Windows\Fonts')
    )

    foreach ($dir in $fontDirs) {
        if (-not (Test-Path $dir)) { continue }
        try {
            $match = Get-ChildItem -Path $dir -Filter 'CaskaydiaCove*NerdFont*.ttf' -ErrorAction Stop | Select-Object -First 1
            if ($match) { return $true }
        } catch {}
    }

    foreach ($registryPath in @('HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts', 'HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts')) {
        try {
            $values = Get-ItemProperty -Path $registryPath -ErrorAction Stop
            foreach ($name in $values.PSObject.Properties.Name) {
                if ($name -match 'CaskaydiaCove' -and $name -match 'Nerd Font') {
                    return $true
                }
            }
        } catch {}
    }

    return $false
}

function Install-PowerShellModules {
    param(
        [string[]]$Modules = @()
    )

    foreach ($module in ($Modules | Sort-Object -Unique)) {
        Ensure-PowerShellModule -Name $module
    }

    if (-not (Test-CaskaydiaFont)) {
        Write-Host ("[WARN] CaskaydiaCove Nerd Font not detected. Download 'Caskaydia Cove' from https://www.nerdfonts.com/font-downloads, then right-click 'CaskaydiaCoveNerdFontMono-Regular.ttf' > Show more options > Install for all users, and set Windows Terminal to use 'CaskaydiaCove NF'.") -ForegroundColor Yellow
    }
}

function Test-PackageInstalled {
    param([string]$PackageId)

    $output = winget list --id $PackageId --exact --accept-source-agreements 2>&1 | Out-String

    # Check if command succeeded and output contains the package ID
    return ($LASTEXITCODE -eq 0 -and $output -match [regex]::Escape($PackageId))
}

{{- $windowsPowerShellModules := (default (list) .windows_powershell_modules) | sortAlpha | uniq }}
{{- $windowsPackages := (default (list) .windows_winget_packages) | sortAlpha | uniq }}
{{- $windowsNonWorkPackages := (default (list) .windows_non_work_winget_packages) | sortAlpha | uniq }}

$powerShellModules = @(
{{- range $windowsPowerShellModules }}
    "{{ . }}"
{{ end }}
)

Install-PowerShellModules -Modules $powerShellModules

$packages = @(
{{- range $windowsPackages }}
    "{{ . }}"
{{ end }}
)

{{- if not .is_work_machine }}
$packages += @(
{{- range $windowsNonWorkPackages }}
    "{{ . }}"
{{ end }}
)
{{ end }}

foreach ($pkg in ($packages | Sort-Object -Unique)) {
    $isInstalled = Test-PackageInstalled -PackageId $pkg

    if ($isInstalled) {
        Write-Host "[INFO] $pkg already installed; skipping."
        continue
    }

    Write-Host "[INFO] Installing $pkg..."

    winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent --source winget
}

$claudeCommand = Get-Command -Name 'claude' -ErrorAction SilentlyContinue

if ($claudeCommand) {
    Write-Host ("[INFO] Claude Code already installed at '{0}'; skipping native installer." -f $claudeCommand.Source)
} else {
    Write-Host "Installing/upgrading Claude Code via native installer..."
    try {
        irm https://claude.ai/install.ps1 | iex
    } catch {
        Write-Host ("[ERROR] Failed to run Claude Code installer: $($_.Exception.Message)") -ForegroundColor Red
    }
}

# Add vim to PATH if installed via winget
function Add-ToPathIfNeeded {
    param([string]$Dir)

    # Add to current session
    if ($env:PATH -notlike "*$Dir*") {
        $env:PATH = "$Dir;$env:PATH"
    }

    # Add to user PATH persistently via registry
    try {
        $userPath = [Environment]::GetEnvironmentVariable('PATH', 'User')
        if ($userPath -notlike "*$Dir*") {
            $newPath = "$Dir;$userPath"
            [Environment]::SetEnvironmentVariable('PATH', $newPath, 'User')
            Write-Host ("[INFO] Added '{0}' to User PATH persistently." -f $Dir)
        }
    } catch {
        Write-Host ("[WARN] Could not persist '{0}' to User PATH: {1}" -f $Dir, $_.Exception.Message) -ForegroundColor Yellow
    }
}

function Ensure-VimInPath {
    # Check if vim is already in PATH
    $vimCmd = Get-Command vim -ErrorAction SilentlyContinue
    if ($vimCmd) {
        Write-Host ("[INFO] vim already in PATH at {0}" -f $vimCmd.Source)
        return
    }

    # Find vim installation directory
    $vimBasePath = Join-Path $env:ProgramFiles 'vim'
    if (-not (Test-Path $vimBasePath)) {
        Write-Host "[INFO] vim not installed in standard location; skipping PATH setup."
        return
    }

    # Find the versioned vim directory (e.g., vim91, vim92, etc.)
    $vimVersionDir = Get-ChildItem -Path $vimBasePath -Directory -Filter 'vim*' -ErrorAction SilentlyContinue |
        Where-Object { $_.Name -match '^vim\d+$' } |
        Sort-Object Name -Descending |
        Select-Object -First 1

    if (-not $vimVersionDir) {
        Write-Host "[WARN] Could not find vim version directory in $vimBasePath" -ForegroundColor Yellow
        return
    }

    $vimExePath = Join-Path $vimVersionDir.FullName 'vim.exe'
    if (Test-Path $vimExePath) {
        Add-ToPathIfNeeded -Dir $vimVersionDir.FullName
        Write-Host ("[INFO] Added vim (version {0}) to PATH." -f $vimVersionDir.Name)
    } else {
        Write-Host ("[WARN] vim.exe not found at expected location: {0}" -f $vimExePath) -ForegroundColor Yellow
    }
}

function Ensure-GoInPath {
    # Check if go is already in PATH
    $goCmd = Get-Command go -ErrorAction SilentlyContinue
    if ($goCmd) {
        Write-Host ("[INFO] go already in PATH at {0}" -f $goCmd.Source)
        return
    }

    # Find Go installation directory
    $goPath = Join-Path $env:ProgramFiles 'Go\bin'
    if (-not (Test-Path $goPath)) {
        Write-Host "[INFO] Go not installed in standard location; skipping PATH setup."
        return
    }

    $goExePath = Join-Path $goPath 'go.exe'
    if (Test-Path $goExePath) {
        Add-ToPathIfNeeded -Dir $goPath
        Write-Host "[INFO] Added Go to PATH."
    } else {
        Write-Host ("[WARN] go.exe not found at expected location: {0}" -f $goExePath) -ForegroundColor Yellow
    }
}

function Ensure-MakeInPath {
    # Check if make is already in PATH
    $makeCmd = Get-Command make -ErrorAction SilentlyContinue
    if ($makeCmd) {
        Write-Host ("[INFO] make already in PATH at {0}" -f $makeCmd.Source)
        return
    }

    # Find GnuWin32 Make installation directory
    # Check both Program Files locations
    $makePaths = @(
        (Join-Path ${env:ProgramFiles(x86)} 'GnuWin32\bin'),
        (Join-Path $env:ProgramFiles 'GnuWin32\bin')
    )

    foreach ($makePath in $makePaths) {
        if (-not (Test-Path $makePath)) {
            continue
        }

        $makeExePath = Join-Path $makePath 'make.exe'
        if (Test-Path $makeExePath) {
            Add-ToPathIfNeeded -Dir $makePath
            Write-Host "[INFO] Added Make to PATH."
            return
        }
    }

    Write-Host "[INFO] Make not installed in standard location; skipping PATH setup."
}

Ensure-VimInPath
Ensure-GoInPath
Ensure-MakeInPath