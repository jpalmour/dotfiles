$initialExecutable = (Get-Process -Id $PID | Select-Object -ExpandProperty Path)
$hostInfo = [PSCustomObject]@{
    Pid              = $PID
    EffectiveBinary  = $initialExecutable
    Edition          = $PSVersionTable.PSEdition
    Version          = $PSVersionTable.PSVersion.ToString()
    CommandPath      = $PSCommandPath
    WorkingDirectory = (Get-Location).Path
}
Write-Host "[DEBUG] Chezmoi PowerShell host info (initial):" ($hostInfo | ConvertTo-Json -Compress)

$ErrorActionPreference = 'Stop'

function Ensure-PowerShellModule {
    param(
        [Parameter(Mandatory)][string]$Name,
        [string]$MinimumVersion
    )

    $installed = Get-Module -ListAvailable -Name $Name | Sort-Object Version -Descending | Select-Object -First 1
    $targetVersion = if ($MinimumVersion) { [Version]$MinimumVersion } else { $null }
    $needsInstall = -not $installed
    if (-not $needsInstall -and $targetVersion) {
        $needsInstall = ([Version]$installed.Version -lt $targetVersion)
    }

    if ($needsInstall) {
        if (-not (Get-Command -Name Install-Module -ErrorAction SilentlyContinue)) {
            throw "Install-Module is unavailable. Install PowerShellGet and retry."
        }

        Write-Host ("[ACTION] Installing PowerShell module '{0}'..." -f $Name)
        try {
            $gallery = Get-PSRepository -Name 'PSGallery' -ErrorAction SilentlyContinue
            if ($gallery -and $gallery.InstallationPolicy -ne 'Trusted') {
                Set-PSRepository -Name 'PSGallery' -InstallationPolicy Trusted -ErrorAction SilentlyContinue
            }
        } catch {}

        $params = @{
            Name = $Name
            Scope = 'CurrentUser'
            Force = $true
            AllowClobber = $true
        }
        if ($MinimumVersion) { $params['MinimumVersion'] = $MinimumVersion }
        if ($PSVersionTable.PSVersion.Major -ge 7) { $params['SkipPublisherCheck'] = $true }

        Install-Module @params -ErrorAction Stop
    } else {
        Write-Host ("[INFO] PowerShell module '{0}' already present (v{1})." -f $Name, $installed.Version)
    }

    Import-Module -Name $Name -ErrorAction Stop
}

function Ensure-PackageProvider {
    param([string]$Name, [string]$MinimumVersion)

    Ensure-PowerShellModule -Name 'PackageManagement' -MinimumVersion '1.4.8.1'

    $provider = Get-PackageProvider -Name $Name -ErrorAction SilentlyContinue
    $targetVersion = if ($MinimumVersion) { [Version]$MinimumVersion } else { $null }
    $needsInstall = -not $provider -or ($targetVersion -and [Version]$provider.Version -lt $targetVersion)

    if ($needsInstall) {
        Write-Host ("[ACTION] Installing package provider '{0}'..." -f $Name)
        $params = @{
            Name = $Name
            Force = $true
            Scope = 'CurrentUser'
        }
        if ($MinimumVersion) { $params['MinimumVersion'] = $MinimumVersion }
        Install-PackageProvider @params -ErrorAction Stop | Out-Null
    } else {
        Write-Host ("[INFO] Package provider '{0}' already available (v{1})." -f $Name, $provider.Version)
    }
}

function Ensure-GetFileHash {
    if (-not (Get-Command -Name Get-FileHash -ErrorAction SilentlyContinue)) {
        try {
            Import-Module -Name Microsoft.PowerShell.Utility -ErrorAction Stop
        } catch {
            Write-Host ("[ERROR] Failed to import 'Microsoft.PowerShell.Utility': {0}" -f $_.Exception.Message) -ForegroundColor Red
            return $false
        }
    }

    if (-not (Get-Command -Name Get-FileHash -ErrorAction SilentlyContinue)) {
        Write-Host "[ERROR] Required PowerShell command 'Get-FileHash' is unavailable. Repair the PowerShell installation and rerun." -ForegroundColor Red
        return $false
    }

    return $true
}

function Test-CaskaydiaFont {
    $fontDirs = @(
        (Join-Path $env:WINDIR 'Fonts'),
        (Join-Path $env:LOCALAPPDATA 'Microsoft\Windows\Fonts')
    )

    foreach ($dir in $fontDirs) {
        if (-not (Test-Path $dir)) { continue }
        try {
            $match = Get-ChildItem -Path $dir -Filter 'CaskaydiaCove*NerdFont*.ttf' -ErrorAction Stop | Select-Object -First 1
            if ($match) { return $true }
        } catch {}
    }

    foreach ($registryPath in @('HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts', 'HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts')) {
        try {
            $values = Get-ItemProperty -Path $registryPath -ErrorAction Stop
            foreach ($name in $values.PSObject.Properties.Name) {
                if ($name -match 'CaskaydiaCove' -and $name -match 'Nerd Font') {
                    return $true
                }
            }
        } catch {}
    }

    return $false
}

function Install-PowerShellModules {
    Ensure-PackageProvider -Name 'NuGet' -MinimumVersion '2.8.5.201'
    Ensure-PowerShellModule -Name 'PowerShellGet' -MinimumVersion '2.2.5'
    Ensure-PowerShellModule -Name 'PSReadLine' -MinimumVersion '2.2.6'
    Ensure-PowerShellModule -Name 'posh-git' -MinimumVersion '1.1.0'
    Ensure-PowerShellModule -Name 'Terminal-Icons' -MinimumVersion '0.9.0'

    if (-not (Test-CaskaydiaFont)) {
        Write-Host "[WARN] CaskaydiaCove Nerd Font not detected. Download 'Caskaydia Cove' from https://www.nerdfonts.com/font-downloads, then right-click 'CaskaydiaCoveNerdFontMono-Regular.ttf' > Show more options > Install for all users, and set Windows Terminal to use 'CaskaydiaCove NF'."
    }
}

function Test-PackageInstalled {
    param([string]$PackageId)

    $output = winget list --id $PackageId --exact --accept-source-agreements 2>&1 | Out-String

    # Check if command succeeded and output contains the package ID
    return ($LASTEXITCODE -eq 0 -and $output -match [regex]::Escape($PackageId))
}

# Post-install handlers for packages that need special setup
$postInstallHandlers = @{
    'Microsoft.PowerShell' = { Install-PowerShellModules }
}

{{- $windowsPackages := (default (list) .windows_winget_packages) | sortAlpha | uniq }}
{{- $windowsNonWorkPackages := (default (list) .windows_non_work_winget_packages) | sortAlpha | uniq }}

$packages = @(
{{- range $windowsPackages }}
    "{{ . }}"
{{ end }}
)

{{- if not .is_work_machine }}
$packages += @(
{{- range $windowsNonWorkPackages }}
    "{{ . }}"
{{ end }}
)
{{ end }}

foreach ($pkg in ($packages | Sort-Object -Unique)) {
    Write-Host "=== $pkg ==="

    $isInstalled = Test-PackageInstalled -PackageId $pkg

    if ($isInstalled) {
        Write-Host "[INFO] $pkg already installed; skipping."

        # Run post-install handler even if already installed (ensures config is up to date)
        if ($postInstallHandlers.ContainsKey($pkg)) {
            & $postInstallHandlers[$pkg]
        }
        continue
    }

    Write-Host "[ACTION] Installing $pkg..."

    # Special handling for PowerShell - uninstall old version if install technology differs
    if ($pkg -eq 'Microsoft.PowerShell') {
        $installResult = winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent 2>&1
        if ($LASTEXITCODE -ne 0 -and $installResult -match 'install technology is different') {
            Write-Host "[WARN] PowerShell has different install technology. Uninstalling old version first..."
            winget uninstall -e --id $pkg --silent --force 2>$null
            Start-Sleep -Seconds 2
            Write-Host "[ACTION] Installing PowerShell $pkg..."
            winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent
        }
    } else {
        winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent
    }

    # Run post-install handler if defined
    if ($postInstallHandlers.ContainsKey($pkg)) {
        & $postInstallHandlers[$pkg]
    }
}

if (Ensure-GetFileHash) {
    Write-Host "Installing/upgrading Claude Code via native installer..."
    try {
      irm https://claude.ai/install.ps1 | iex
    } catch {
      Write-Host "[WARN] Failed to run Claude Code installer: $($_.Exception.Message)"
    }
} else {
    Write-Host "[WARN] Skipping Claude Code installer because 'Get-FileHash' is unavailable."
}