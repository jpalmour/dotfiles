$ErrorActionPreference = 'Stop'

function Ensure-PackageProvider {
    param([string]$Name, [Version]$MinimumVersion)

    # PackageProvider is only needed in Windows PowerShell 5.1, not in PowerShell 7+
    if ($PSVersionTable.PSVersion.Major -ge 7) {
        return
    }

    try {
        $provider = Get-PackageProvider -Name $Name -ErrorAction SilentlyContinue
        if (-not $provider -or $provider.Version -lt $MinimumVersion) {
            Install-PackageProvider -Name $Name -MinimumVersion $MinimumVersion -Force -Scope CurrentUser *>$null
        }
    } catch {
        Write-Host ("[WARN] Failed to ensure package provider '{0}': {1}" -f $Name, $_.Exception.Message)
    }
}

function Ensure-Module {
    param(
        [Parameter(Mandatory)] [string]$Name,
        [string]$MinimumVersion
    )

    try {
        # Ensure PSGallery is trusted to prevent interactive prompts during installation
        try {
            $gallery = Get-PSRepository -Name 'PSGallery' -ErrorAction SilentlyContinue
            if ($gallery -and $gallery.InstallationPolicy -ne 'Trusted') {
                Set-PSRepository -Name 'PSGallery' -InstallationPolicy Trusted -ErrorAction SilentlyContinue
            }
        } catch {
            # PSRepository commands may not be available; continue without them
        }

        $module = Get-Module -ListAvailable -Name $Name | Sort-Object Version -Descending | Select-Object -First 1
        $needsInstall = -not $module
        if (-not $needsInstall -and $MinimumVersion) {
            $needsInstall = ([Version]$module.Version -lt [Version]$MinimumVersion)
        }

        if ($needsInstall) {
            Write-Host ("[ACTION] Installing PowerShell module '{0}'..." -f $Name)
            $installParams = @{
                Name = $Name
                Scope = 'CurrentUser'
                Force = $true
                AllowClobber = $true
            }
            if ($MinimumVersion) { $installParams['MinimumVersion'] = $MinimumVersion }

            # Try with SkipPublisherCheck if available (PowerShell 7+)
            if ($PSVersionTable.PSVersion.Major -ge 7) {
                $installParams['SkipPublisherCheck'] = $true
            }

            Install-Module @installParams -ErrorAction Stop

            # Verify the module can be imported
            Import-Module -Name $Name -ErrorAction Stop
            Write-Host ("[OK] Installed PowerShell module '{0}'." -f $Name)
        } else {
            Write-Host ("[INFO] PowerShell module '{0}' already present (v{1})." -f $Name, $module.Version)
        }
    } catch {
        Write-Host ("[ERROR] Failed to install PowerShell module '{0}': {1}" -f $Name, $_.Exception.Message) -ForegroundColor Red
        Write-Host ("        Run 'Install-Module -Name {0} -Scope CurrentUser -Force' manually to diagnose." -f $Name) -ForegroundColor Yellow
    }
}

function Test-CaskaydiaFont {
    $fontDirs = @(
        (Join-Path $env:WINDIR 'Fonts'),
        (Join-Path $env:LOCALAPPDATA 'Microsoft\Windows\Fonts')
    )

    foreach ($dir in $fontDirs) {
        if (-not (Test-Path $dir)) { continue }
        try {
            $match = Get-ChildItem -Path $dir -Filter 'CaskaydiaCove*NerdFont*.ttf' -ErrorAction Stop | Select-Object -First 1
            if ($match) { return $true }
        } catch {}
    }

    foreach ($registryPath in @('HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts', 'HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts')) {
        try {
            $values = Get-ItemProperty -Path $registryPath -ErrorAction Stop
            foreach ($name in $values.PSObject.Properties.Name) {
                if ($name -match 'CaskaydiaCove' -and $name -match 'Nerd Font') {
                    return $true
                }
            }
        } catch {}
    }

    return $false
}

function Install-PowerShellModules {
    Ensure-PackageProvider -Name 'NuGet' -MinimumVersion ([Version]'2.8.5.201')
    Ensure-Module -Name 'PSReadLine' -MinimumVersion '2.2.6'
    Ensure-Module -Name 'posh-git' -MinimumVersion '1.1.0'
    Ensure-Module -Name 'Terminal-Icons' -MinimumVersion '0.9.0'

    if (-not (Test-CaskaydiaFont)) {
        Write-Host "[WARN] CaskaydiaCove Nerd Font not detected. Download 'Caskaydia Cove' from https://www.nerdfonts.com/font-downloads, then right-click 'CaskaydiaCoveNerdFontMono-Regular.ttf' > Show more options > Install for all users, and set Windows Terminal to use 'CaskaydiaCove NF'."
    }
}

function Test-PackageInstalled {
    param([string]$PackageId)

    $output = winget list --id $PackageId --exact --accept-source-agreements 2>&1 | Out-String

    # Check if command succeeded and output contains the package ID
    return ($LASTEXITCODE -eq 0 -and $output -match [regex]::Escape($PackageId))
}

function Test-PackageUpgradeAvailable {
    param([string]$PackageId)

    # Use winget upgrade to check if an upgrade is available for this specific package
    $output = winget upgrade --id $PackageId --exact --source winget --accept-source-agreements 2>&1 | Out-String

    # If the package appears in the upgrade list, an upgrade is available
    # The output will contain the package ID if an upgrade exists
    return ($LASTEXITCODE -eq 0 -and $output -match [regex]::Escape($PackageId))
}

# Post-install handlers for packages that need special setup
$postInstallHandlers = @{
    'Microsoft.PowerShell' = { Install-PowerShellModules }
}

$packages = @(
    "BurntSushi.ripgrep.MSVC"
    "Docker.DockerDesktop"
    "Git.Git"
    "GitHub.cli"
    "Google.Chrome"
    "Postman.Postman"
    "Microsoft.PowerShell"
    "Microsoft.WindowsTerminal"
    "SlackTechnologies.Slack"
    "vim.vim"
    "JanDeDobbeleer.OhMyPosh"
    "jqlang.jq"
)

{{- if not .is_work_machine }}
$packages += "OpenAI.ChatGPT"
$packages += "Anthropic.Claude"
{{- end }}

foreach ($pkg in ($packages | Sort-Object -Unique)) {
    Write-Host "=== $pkg ==="

    $isInstalled = Test-PackageInstalled -PackageId $pkg

    if ($isInstalled) {
        # Check if an upgrade is available
        $upgradeAvailable = Test-PackageUpgradeAvailable -PackageId $pkg

        if ($upgradeAvailable) {
            Write-Host "[ACTION] Upgrading $pkg to latest version..."
            winget upgrade -e --id $pkg --accept-source-agreements --accept-package-agreements --silent
        } else {
            Write-Host "[INFO] $pkg already installed and up-to-date; skipping."
        }

        # Run post-install handler even if already installed (ensures config is up to date)
        if ($postInstallHandlers.ContainsKey($pkg)) {
            & $postInstallHandlers[$pkg]
        }
        continue
    }

    Write-Host "[ACTION] Installing $pkg..."

    # Special handling for PowerShell - uninstall old version if install technology differs
    if ($pkg -eq 'Microsoft.PowerShell') {
        $installResult = winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent 2>&1
        if ($LASTEXITCODE -ne 0 -and $installResult -match 'install technology is different') {
            Write-Host "[WARN] PowerShell has different install technology. Uninstalling old version first..."
            winget uninstall -e --id $pkg --silent --force 2>$null
            Start-Sleep -Seconds 2
            Write-Host "[ACTION] Installing PowerShell $pkg..."
            winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent
        }
    } else {
        winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent
    }

    # Run post-install handler if defined
    if ($postInstallHandlers.ContainsKey($pkg)) {
        & $postInstallHandlers[$pkg]
    }
}

Write-Host "Installing/upgrading Claude Code via native installer..."
try {
  irm https://claude.ai/install.ps1 | iex
} catch {
  Write-Host "[WARN] Failed to run Claude Code installer: $($_.Exception.Message)"
}