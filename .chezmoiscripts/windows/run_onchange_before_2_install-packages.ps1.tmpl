$ErrorActionPreference = 'Stop'

function Ensure-PowerShellModule {
    param([Parameter(Mandatory)][string]$Name)

    $installed = Get-Module -ListAvailable -Name $Name | Sort-Object Version -Descending | Select-Object -First 1

    if (-not $installed) {
        if (-not (Get-Command -Name Install-Module -ErrorAction SilentlyContinue)) {
            Write-Host ("[WARN] Install-Module not available; install module '{0}' manually." -f $Name) -ForegroundColor Yellow
            return
        }

        Write-Host ("[ACTION] Installing PowerShell module '{0}'..." -f $Name)
        try {
            Install-Module -Name $Name -Scope CurrentUser -Force -AllowClobber -ErrorAction Stop | Out-Null
        } catch {
            Write-Host ("[ERROR] Failed to install module '{0}': {1}" -f $Name, $_.Exception.Message) -ForegroundColor Red
            return
        }
    } else {
        Write-Host ("[INFO] PowerShell module '{0}' already present (v{1})." -f $Name, $installed.Version)
    }

    try {
        Import-Module -Name $Name -ErrorAction Stop
    } catch {
        Write-Host ("[WARN] Failed to import module '{0}': {1}" -f $Name, $_.Exception.Message) -ForegroundColor Yellow
    }
}

function Ensure-GetFileHash {
    if (-not (Get-Command -Name Get-FileHash -ErrorAction SilentlyContinue)) {
        try {
            Import-Module -Name Microsoft.PowerShell.Utility -ErrorAction Stop
        } catch {
            Write-Host ("[ERROR] Failed to import 'Microsoft.PowerShell.Utility': {0}" -f $_.Exception.Message) -ForegroundColor Red
            return $false
        }
    }

    if (-not (Get-Command -Name Get-FileHash -ErrorAction SilentlyContinue)) {
        Write-Host "[ERROR] Required PowerShell command 'Get-FileHash' is unavailable. Repair the PowerShell installation and rerun." -ForegroundColor Red
        return $false
    }

    return $true
}

function Test-CaskaydiaFont {
    $fontDirs = @(
        (Join-Path $env:WINDIR 'Fonts'),
        (Join-Path $env:LOCALAPPDATA 'Microsoft\Windows\Fonts')
    )

    foreach ($dir in $fontDirs) {
        if (-not (Test-Path $dir)) { continue }
        try {
            $match = Get-ChildItem -Path $dir -Filter 'CaskaydiaCove*NerdFont*.ttf' -ErrorAction Stop | Select-Object -First 1
            if ($match) { return $true }
        } catch {}
    }

    foreach ($registryPath in @('HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts', 'HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts')) {
        try {
            $values = Get-ItemProperty -Path $registryPath -ErrorAction Stop
            foreach ($name in $values.PSObject.Properties.Name) {
                if ($name -match 'CaskaydiaCove' -and $name -match 'Nerd Font') {
                    return $true
                }
            }
        } catch {}
    }

    return $false
}

function Install-PowerShellModules {
    Ensure-PowerShellModule -Name 'PackageManagement'
    Ensure-PowerShellModule -Name 'PowerShellGet'
    Ensure-PowerShellModule -Name 'PSReadLine'
    Ensure-PowerShellModule -Name 'posh-git'
    Ensure-PowerShellModule -Name 'Terminal-Icons'

    if (-not (Test-CaskaydiaFont)) {
        Write-Host "[WARN] CaskaydiaCove Nerd Font not detected. Download 'Caskaydia Cove' from https://www.nerdfonts.com/font-downloads, then right-click 'CaskaydiaCoveNerdFontMono-Regular.ttf' > Show more options > Install for all users, and set Windows Terminal to use 'CaskaydiaCove NF'."
    }
}

function Test-PackageInstalled {
    param([string]$PackageId)

    $output = winget list --id $PackageId --exact --accept-source-agreements 2>&1 | Out-String

    # Check if command succeeded and output contains the package ID
    return ($LASTEXITCODE -eq 0 -and $output -match [regex]::Escape($PackageId))
}

# Post-install handlers for packages that need special setup
$postInstallHandlers = @{
    'Microsoft.PowerShell' = { Install-PowerShellModules }
}

{{- $windowsPackages := (default (list) .windows_winget_packages) | sortAlpha | uniq }}
{{- $windowsNonWorkPackages := (default (list) .windows_non_work_winget_packages) | sortAlpha | uniq }}

$packages = @(
{{- range $windowsPackages }}
    "{{ . }}"
{{ end }}
)

{{- if not .is_work_machine }}
$packages += @(
{{- range $windowsNonWorkPackages }}
    "{{ . }}"
{{ end }}
)
{{ end }}

foreach ($pkg in ($packages | Sort-Object -Unique)) {
    Write-Host "=== $pkg ==="

    $isInstalled = Test-PackageInstalled -PackageId $pkg

    if ($isInstalled) {
        Write-Host "[INFO] $pkg already installed; skipping."

        # Run post-install handler even if already installed (ensures config is up to date)
        if ($postInstallHandlers.ContainsKey($pkg)) {
            & $postInstallHandlers[$pkg]
        }
        continue
    }

    Write-Host "[ACTION] Installing $pkg..."

    # Special handling for PowerShell - uninstall old version if install technology differs
    if ($pkg -eq 'Microsoft.PowerShell') {
        $installResult = winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent 2>&1
        if ($LASTEXITCODE -ne 0 -and $installResult -match 'install technology is different') {
            Write-Host "[WARN] PowerShell has different install technology. Uninstalling old version first..."
            winget uninstall -e --id $pkg --silent --force 2>$null
            Start-Sleep -Seconds 2
            Write-Host "[ACTION] Installing PowerShell $pkg..."
            winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent
        }
    } else {
        winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent
    }

    # Run post-install handler if defined
    if ($postInstallHandlers.ContainsKey($pkg)) {
        & $postInstallHandlers[$pkg]
    }
}

if (Ensure-GetFileHash) {
    Write-Host "Installing/upgrading Claude Code via native installer..."
    try {
      irm https://claude.ai/install.ps1 | iex
    } catch {
      Write-Host "[WARN] Failed to run Claude Code installer: $($_.Exception.Message)"
    }
} else {
    Write-Host "[WARN] Skipping Claude Code installer because 'Get-FileHash' is unavailable."
}