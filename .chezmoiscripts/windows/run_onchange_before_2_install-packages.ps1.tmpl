$ErrorActionPreference = 'Stop'

function Ensure-PowerShellModule {
    param([Parameter(Mandatory)][string]$Name)

    $installed = Get-Module -ListAvailable -Name $Name | Sort-Object Version -Descending | Select-Object -First 1

    if (-not $installed) {
        if (-not (Get-Command -Name Install-Module -ErrorAction SilentlyContinue)) {
            Write-Host ("[WARN] Install-Module not available; install module '{0}' manually." -f $Name) -ForegroundColor Yellow
            return
        }

        Write-Host ("[ACTION] Installing PowerShell module '{0}'..." -f $Name)
        try {
            Install-Module -Name $Name -Scope CurrentUser -Force -AllowClobber -ErrorAction Stop | Out-Null
        } catch {
            Write-Host ("[ERROR] Failed to install module '{0}': {1}" -f $Name, $_.Exception.Message) -ForegroundColor Red
            return
        }
    } else {
        Write-Host ("[INFO] PowerShell module '{0}' already present (v{1})." -f $Name, $installed.Version)
    }

    try {
        Import-Module -Name $Name -ErrorAction Stop
    } catch {
        Write-Host ("[WARN] Failed to import module '{0}': {1}" -f $Name, $_.Exception.Message) -ForegroundColor Yellow
    }
}

function Test-CaskaydiaFont {
    $fontDirs = @(
        (Join-Path $env:WINDIR 'Fonts'),
        (Join-Path $env:LOCALAPPDATA 'Microsoft\Windows\Fonts')
    )

    foreach ($dir in $fontDirs) {
        if (-not (Test-Path $dir)) { continue }
        try {
            $match = Get-ChildItem -Path $dir -Filter 'CaskaydiaCove*NerdFont*.ttf' -ErrorAction Stop | Select-Object -First 1
            if ($match) { return $true }
        } catch {}
    }

    foreach ($registryPath in @('HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts', 'HKCU:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts')) {
        try {
            $values = Get-ItemProperty -Path $registryPath -ErrorAction Stop
            foreach ($name in $values.PSObject.Properties.Name) {
                if ($name -match 'CaskaydiaCove' -and $name -match 'Nerd Font') {
                    return $true
                }
            }
        } catch {}
    }

    return $false
}

function Install-PowerShellModules {
    Ensure-PowerShellModule -Name 'PackageManagement'
    Ensure-PowerShellModule -Name 'PowerShellGet'
    Ensure-PowerShellModule -Name 'PSReadLine'
    Ensure-PowerShellModule -Name 'posh-git'
    Ensure-PowerShellModule -Name 'Terminal-Icons'

    if (-not (Test-CaskaydiaFont)) {
        Write-Host "[WARN] CaskaydiaCove Nerd Font not detected. Download 'Caskaydia Cove' from https://www.nerdfonts.com/font-downloads, then right-click 'CaskaydiaCoveNerdFontMono-Regular.ttf' > Show more options > Install for all users, and set Windows Terminal to use 'CaskaydiaCove NF'."
    }
}

function Test-PackageInstalled {
    param([string]$PackageId)

    $output = winget list --id $PackageId --exact --accept-source-agreements 2>&1 | Out-String

    # Check if command succeeded and output contains the package ID
    return ($LASTEXITCODE -eq 0 -and $output -match [regex]::Escape($PackageId))
}

{{- $windowsPackages := (default (list) .windows_winget_packages) | sortAlpha | uniq }}
{{- $windowsNonWorkPackages := (default (list) .windows_non_work_winget_packages) | sortAlpha | uniq }}

Install-PowerShellModules

$packages = @(
{{- range $windowsPackages }}
    "{{ . }}"
{{ end }}
)

{{- if not .is_work_machine }}
$packages += @(
{{- range $windowsNonWorkPackages }}
    "{{ . }}"
{{ end }}
)
{{ end }}

foreach ($pkg in ($packages | Sort-Object -Unique)) {
    Write-Host "=== $pkg ==="

    $isInstalled = Test-PackageInstalled -PackageId $pkg

    if ($isInstalled) {
        Write-Host "[INFO] $pkg already installed; skipping."
        continue
    }

    Write-Host "[ACTION] Installing $pkg..."

    winget install -e --id $pkg --accept-source-agreements --accept-package-agreements --silent
}

$claudeCommand = Get-Command -Name 'claude' -ErrorAction SilentlyContinue

if ($claudeCommand) {
    Write-Host ("[INFO] Claude Code already installed at '{0}'; skipping native installer." -f $claudeCommand.Source)
} else {
    Write-Host "Installing/upgrading Claude Code via native installer..."
    try {
        irm https://claude.ai/install.ps1 | iex
    } catch {
        Write-Host "[WARN] Failed to run Claude Code installer: $($_.Exception.Message)"
    }
}